<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xml:space="preserve"
                    xmlns:system="clr-namespace:System;assembly=mscorlib">
    
    <!--StepByStepPage Ressources-->
    
    <SolidColorBrush x:Key="TileSolidColor" Color="#AFC8E6C9"/>
    <Image x:Key="StepByStepBackground" Source="/Images/aead.png" RenderOptions.BitmapScalingMode="HighQuality" Stretch="None" HorizontalAlignment="Center" VerticalAlignment="Center"/>
    
        <!--StepByStepPage StepDescripton and Title-->
    
    <system:String x:Key="Step0Title">Einleitung</system:String>
    <system:String x:Key="Step0">        Weshalb AES-GCM?
        
Der Galois/Counter Mode der AES-Verschlüsselung ermöglicht eine Verschlüsselung des Plaintextes und garantiert die Integrität des generierten Ciphertextes, sowie zusätzlicher unverschlüsselter Daten durch eine kryptografische Checksumme.
Eine solche Art der Verschlüsselung und Authentisierung nennt man auch Authenticated Encryption with Associated Data (AEAD).

Schritt 1: Vorbereitung
Schritt 2: Verschlüsselung 
Schritt 3: Additional Authenticated Data 
Schritt 4: Ciphertext-Authentisierung
Schritt 5: Wiederholung 
Schritt 6: Abschluss und Rückgabe
    </system:String>
    <system:String x:Key="Step1Title">Vorbereitung</system:String>
    <system:String x:Key="Step1">
Der Hash-Subkey H wird berechnet. Dazu wird ein Block von 128 Nullen (0128) mit dem Schlüssel K AES-verschlüsselt.
Dieser Subkey wird für die Berechnung des Message Authentication Codes (MAC), also für die Authentisierung, benötigt. In AES-GCM wird dieser MAC «Auth-Tag» genannt.

Hinweis: die Daten beziehen sich auf den Test Case 16 aus der offiziellen GCM Spezifikation.
    </system:String>
    <system:String x:Key="Step2">
Der «Counter 0»-Block wird aus dem Initialisierungsvektor (IV) hergeleitet. 
Dazu wird zum 96 Bit-langen IV ein 32 Bit langes Padding von Nullbits und einer 1 am Ende hinzugefügt, so dass schlussendlich ein Block mit 128 Bit resultiert.

Hinweis: die Daten beziehen sich auf den Test Case 16 aus der offiziellen GCM Spezifikation.
    </system:String>
    <system:String x:Key="Step3Title">Verschlüsselung</system:String>
    <system:String x:Key="Step3">
Auf den «Counter 0»-Block wird eine Increment-Funktion angewendet, woraus der «Counter 1» resultiert.
    </system:String>
    <system:String x:Key="Step4">
Der «Counter 1»-Block wird anschliessend mit dem Schlüssel K AES-verschlüsselt, so dass ein Output von 128 pseudo-zufälligen Bits generiert wird, die vom Schlüssel K und dem Counterwert abhängen.
    </system:String>
    <system:String x:Key="Step5">
Der Plaintext wird in 128 Bit-Blöcke aufgeteilt. Der erste Plaintext-Block wird mit dem zuvor AES-verschlüsselten «Counter 1»-Block XOR-verknüpft.
Daraus entsteht der erste Ciphertext-Block.
    </system:String>
    <system:String x:Key="Step6Title">Additional Authenticated Data</system:String>
    <system:String x:Key="Step6">
Die Additional Authenticated Data (AAD) ist jener Teil der Eingabedaten, welcher durch den AES-GCM-Algorithmus zwar authentisiert, aber nicht verschlüsselt wird.
Die Eingabe dieser Daten ist optional. Die Authentizität wird durch die Bildung eines MAC gewährleistet.
    </system:String>
    <system:String x:Key="Step7">
Die Generierung des MAC geschieht durch die Multiplikation der AAD in einem Galois-Feld mit dem zu Beginn berechneten Hash-Subkey H.
Dabei steht MultH für die Multiplikation innerhalb des Galois-Feldes. Die dabei durchgeführten Berechnungen sind nicht Bestandteil dieser Anleitung.
    </system:String>
    <system:String x:Key="Step8">
Ein Beispiel für AAD ist der Versand von Daten über einen unsicheren Kanal. Die Payload wird verschlüsselt und authentisiert, die IP-Adressen jedoch nur authentisiert. Diese dürfen für die Übertragung nicht verschlüsselt werden, da dem Router das Ziel sonst nicht bekannt ist.
Werden keine Daten verschlüsselt, sondern nur die Integritätsprüfung durchlaufen, spricht man von einem Galois Message Authentication Code (GMAC).
    </system:String>
    <system:String x:Key="Step9Title">Ciphertext – Authentifizierung</system:String>
    <system:String x:Key="Step9">
Die im vorherigen Schritt berechneten Daten aus der Galois-Feld Multiplikation werden mit dem ersten Ciphertext-Block mittels XOR verknüpft.
    </system:String>
    <system:String x:Key="Step10">
Das Resultat der XOR-Verknüpfung von Ciphertext und der Galois-Feld Multiplikation wird ebenfalls wieder in einem Galois-Feld mit dem Hash-Subkey H multipliziert.
    </system:String>
    <system:String x:Key="Step11Title">Wiederholung</system:String>
    <system:String x:Key="Step11">
Der Schritt Verschlüsselung, sowie der Schritt Ciphertext-Authentisierung, werden nun so lange wiederholt, bis alle 128 Bit-Blöcke des Plaintextes verschlüsselt sind und der MAC darüber berechnet wurde.
Ist der letzte Plaintext-Block kleiner als 128 Bit wird dessen Grösse zur Berechnung kein Padding angewendet, sondern der restliche Plaintext bitweise mittels XOR verschlüsselt.
    </system:String>
    <system:String x:Key="Step12Title">Abschluss und Rückgabe</system:String>
    <system:String x:Key="Step12">
Damit keine Attacken auf den MAC, welcher auf einer variablen Anzahl Input-Bits basiert, gemacht werden können, wird sowohl die Länge der AAD (len(A)), als auch die Ciphertext-Länge (len(C)) mitauthentifiziert. 
Dazu werden die beiden Längen, in 64 Bit-Repräsentation, aneinandergehängt. Es folgt eine XOR-Verknüpfung mit dem Resultat aus der Galois-Feld Multiplikation des allerletzten Ciphertextes. Nach der Verknüpfung wird dieser Wert nochmals in einem Galois-Feld mit dem Hash-Subkey multipliziert.
    </system:String>
    <system:String x:Key="Step13">
Da der IV ebenfalls authentisiert werden soll, und dieser bereits im «Counter 0»-Block enthalten ist, wird dieser Block ebenfalls in den MAC miteinberechnet. 
Dies geschieht indem der «Counter 0»-Block zuerst, wie alle anderen Blöcke, mit dem Schlüssel K AES-verschlüsselt wird. Anschliessend wird auf diese AES-Verschlüsselung und das Resultat der vorhergehenden Galois-Multiplikation die XOR-Funktion angewendet.
    </system:String>
    <system:String x:Key="Step14">
Der berechnete MAC, bei AES-GCM Auth Tag genannt, ist nun fast berechnet. 
Es findet nur noch ein Truncating, also eine Verkürzung, der Bit-Sequenz auf die gewünschte Länge statt. Dazu wird die verlangte Anzahl der Most Significant Bits aus dem Resultat der letzten XOR-Verknüpfung verwendet.
Um eine grösstmögliche Sicherheit zu erreichen wird aber meist der ungekürzte 128 Bit grosse Auth Tag verwendet.
    </system:String>
    <system:String x:Key="Step15">
Zuletzt werden Ciphertext und Authentication Tag zurückgegeben.
Für die Entschlüsselung und Überprüfung des MAC wird nebst diesen beiden Werten auch der IV und die AAD benötigt. Ersterer für die erneute Berechnung aller Counter, der Zweite für die Berechnung und den anschliessenden Vergleich mit dem MAC.
Der Ciphertext wird am Ende dieselbe Länge wie der zu Beginn eingegebene Plaintext besitzen.
    </system:String>
    <system:String x:Key="Step16Title">Erweiterung/Zu beachten</system:String>
    <system:String x:Key="Step16">
Der Initialisierungsvektor muss unique sein, ansonsten besteht die Möglichkeit Rückschlüsse auf den Plaintext zu machen. Dies deshalb, weil zwei gleiche Counter-Blöcke auch genau gleich verschlüsselt werden. Unterschiede im Ciphertext stammen allein daher, dass Unterschiede im Plaintext vorhanden sind.

Die Grösse des zu verschlüsselnden Plaintextes pro IV ist genau aus diesem Grund beschränkt. Werden nämlich zu viele Counter-Blöcke gebildet, steigt die Wahrscheinlichkeit einer Wiederholung der Bit-Sequenzen immer mehr an. Der Plaintext darf deshalb eine Grösse von 64GB nicht übersteigen.
    </system:String>
    <system:String x:Key="Step17Title">Rückblick</system:String>
    <system:String x:Key="Step17">
Der AES-GCM Algorithmus bietet eine Möglichkeit für die gleichzeitige Verschlüsselung und Authentifizierung von Plaintext.
Ein grosser Vorteil dabei ist die Geschwindigkeit. 
Einerseits können alle Counter-Blöcke vorberechnet werden, sobald der IV und die Plaintext-Länge bekannt sind. Andererseits kann die Authentifizierung von Ciphertext-Blöcken (grün markiert, mit Input Plaintext X) und die Verschlüsselung von weiteren Plaintext-Blöcken (orange markiert, mit Input Plaintext X + 1) unabhängig voneinander, und somit parallel, ablaufen.
    </system:String>
    <system:String x:Key="Step18">
Weiter bietet die Verwendung des Counter-Block Mode (CTR) folgenden Vorteil gegenüber dem Electronic Codebook Mode (ECB-Mode): 
Wird beispielsweise ein Bild, mit vielen gleichen Farbpunkten, verschlüsselt, so sehen die Plaintext-Blöcke mit gleichen Farbpunkten nach der Verschlüsselung beim ECB-Mode alle gleich aus. Beim Counter-Block Mode wird dies mittels jeweils unterschiedlichen Counter-Blöcken verhindert und es können beispielsweise bei Bildern keine Muster mehr erkannt werden.
    </system:String>
    
        <!--StepByStepPage Input & Output-->
    
    
    
    <!--Overview Ressources-->
    
        <!--Overview Text-->

    <system:String x:Key="VorbereitungText">In der Vorbereitungsphase wird der Hash-Subkey H
sowie der «Counter 0»-Block berechnet.</system:String>

    <system:String x:Key="VerschlüsselungText">Bei der Verschlüsselung wird der
erste Plaintextblock AES-verschlüsselt.</system:String>

    <system:String x:Key="AdditionalAuthenticatedDataText">Dem Algorithmus werden weitere authentifizierte,
aber nicht verschlüsselte Daten hinzugefügt.</system:String>

    <system:String x:Key="CiphertextAuthentifizierungText">Die Authentifizierung geschieht über
eine Multiplikation in einem Galois-Feld.</system:String>

    <system:String x:Key="WiederholungText">Die Verschlüsselung und Authentifizierung
werden wiederholt angewendet.</system:String>

    <system:String x:Key="AbschlussUndRückgabeText">Die Textlänge und der «Counter 0»-Block werden
ebenfalls authentifiziert. Am Ende wird
der Ciphertext und das Tag zurückgegeben.</system:String>

        <!--Overview Background-->
    
    <Image x:Key="BackgroundImage" Source="/Images/aead.png" RenderOptions.BitmapScalingMode="HighQuality" Stretch="None" HorizontalAlignment="Center" VerticalAlignment="Center"/>
    <SolidColorBrush x:Key="BackAreaBrush" Color="#AFC8E6C9"/>
    <SolidColorBrush x:Key="NoBackAreaBrush" Color="White"/>
    
</ResourceDictionary>