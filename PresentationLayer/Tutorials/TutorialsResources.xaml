<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:system="clr-namespace:System;assembly=mscorlib">

    <system:String x:Key="Step1">Einleitung: Weshalb AES-GCM?
        Der Galois/Counter Mode der AES-Verschlüsselung ermöglicht eine Verschlüsselung des Plaintextes 
        sowie eine Authentifizierung des Ciphertextes und zusätzlichen Daten. 
        Eine solche Art der Verschlüsselung und Authentifizierung nennt man auch Authenticated Encryption with Associated Data (AEAD).
        Schritt 1: Vorbereitung
        Schritt 2: Verschlüsselung 
        Schritt 3: Additional Authenticated Data 
        Schritt 4: Ciphertext-Authentifizierung
        Schritt 5: Wiederholung 
        Schritt 6: Abschluss und Rückgabe
    </system:String>
    <system:String x:Key="Step2">Vorbereitung:
        Der Hash-Subkey H wird berechnet. Dazu wird ein Block von 128 Nullen (0128) mit dem Schlüssel K AES verschlüsselt. 
        Der Subkey wird für die Berechnung des MAC, also für die Authentifizierung, benötigt. In AES-GCM wird dieser MAC Tag genannt.
    </system:String>
    <system:String x:Key="Step3">Der «Counter 0»-Block wird aus dem Initialisierungsvektor (IV) hergeleitet. 
        Dazu wird zum IV ein Padding hinzugefügt, so dass schlussendlich ein Block mit 128Bit resultiert.
    </system:String>
    <system:String x:Key="Step4">Verschlüsselung:
        Auf den «Counter 0»-Block wird eine Increment-Funktion angewendet, woraus der «Counter 1» resultiert.
    </system:String>
    <system:String x:Key="Step5">Der «Counter 1»-Block wird anschliessend mit dem Schlüssel K AES-verschlüsselt.
    </system:String>
    <system:String x:Key="Step6">Der Plaintext wird in 128Bit-Blöcke aufgeteilt. Der erste Plaintext-Block wird mit dem zuvor AES-verschlüsselten «Counter 1»-Block XOR-verknüpft.
        Daraus entsteht der erste Ciphertext-Block.
    </system:String>
    <system:String x:Key="Step7">Additional Authenticated Data
        Die Additional Authenticated Data (AAD) ist jener Teil der Eingabedaten, welcher durch den AES-GCM-Algorithmus zwar Authentifiziert, aber nicht verschlüsselt wird.
        Die Eingabe dieser Daten ist optional. Die Authentizität wird durch die Bildung eines MAC gewährleistet.
    </system:String>
    <system:String x:Key="Step8">Die Generierung des MAC geschieht durch die Multiplikation der AAD in einem Galois-Feld mit dem zu Beginn berechneten Hash-Subkey H.
        Dabei steht MultH für die Multiplikation innerhalb des Galois-Feldes. Die dabei durchgeführten Berechnungen sind nicht Bestandteil dieser Anleitung.
    </system:String>
    <system:String x:Key="Step9">Ein Beispiel für AAD ist der Versand von Daten über einen unsicheren Kanal.
        Die Payload wird verschlüsselt und authentifiziert, die IP-Adressen jedoch nur authentifiziert.
        Diese dürfen für die Übertragung nicht verschlüsselt werden, da dem Router das Ziel sonst nicht bekannt ist.
        Werden keine Daten verschlüsselt, sondern nur die Integritätsprüfung durchlaufen, spricht man von einem Galois Message Authentication Code (GMAC).
    </system:String>
    <system:String x:Key="Step10">Ciphertext – Authentifizierung
        Die im vorherigen Schritt berechneten Daten aus der Galois-Feld Multiplikation werden mit dem ersten Ciphertext-Block mittels XOR verknüpft.
    </system:String>
    <system:String x:Key="Step11">Das Resultat dieser XOR-Verknüpfung wird ebenfalls wieder in einem Galois-Feld mit dem Hash-Subkey H multipliziert.
    </system:String>
    <system:String x:Key="Step12">Wiederholung
	    Der Schritt Verschlüsselung, sowie der Schritt Ciphertext-Authentifizierung, werden nun so lange wiederholt, bis alle 128Bit-Blöcke des Plaintextes verschlüsselt sind
        und der MAC darüber berechnet wurde. Ist der letzte Plaintext-Block kleiner als 128Bit wird dessen Grösse zur Berechnung verwendet.
    </system:String>
    <system:String x:Key="Step13">Abschluss und Rückgabe
        Damit keine Attacken auf den MAC, welcher auf einer variablen Anzahl Input-Bits basiert, gemacht werden können, wird sowohl die Länge der AAD (len(A)),
        als auch die Ciphertext-Länge (len(C)) mitauthentifiziert. Dazu werden die beiden Längen, in 64Bit-Repräsentation, aneinandergehängt.
        Es folgt eine XOR-Verknüpfung mit dem Resultat aus der Galois-Feld Multiplikation des allerletzten Ciphertextes.
        Nach der Verknüpfung wird dieser Wert nochmals in einem Galois-Feld mit dem Hash-Subkey multipliziert.
    </system:String>
    <system:String x:Key="Step14">Da der IV ebenfalls authentifiziert werden soll, und dieser bereits im «Counter 0»-Block enthalten ist,
        wird dieser Block ebenfalls in den MAC miteinberechnet. Dies geschieht indem der «Counter 0»-Block zuerst, wie alle anderen Blöcke, mit dem Schlüssel K AES verschlüsselt wird.
        Anschliessend wird auf diese AES Verschlüsselung und das Resultat der vorhergehenden Galois-Multiplikation die XOR-Funktion angewendet.
    </system:String>
    <system:String x:Key="Step15">Der berechnete MAC, bei AES-GCM Tag genannt, ist nun fast berechnet. Es findet nur noch ein Truncating, also eine Verkürzung, 
        der Bit-Sequenz auf die gewünschte Länge statt. Dazu wird die verlangte Anzahl Most Significant Bits aus dem Resultat der letzten XOR-Verknüpfung verwendet.
    </system:String>
    <system:String x:Key="Step16">Zuletzt werden Ciphertext und Authentication Tag zurückgegeben.
        Für die Entschlüsselung und Überprüfung des MAC wird nebst diesen beiden Werten auch der IV und die AAD benötigt.
        Ersterer für die erneute Berechnung aller Counter, der Zweite für die Berechnung und den anschliessenden Vergleich mit dem MAC.
        Der Ciphertext wird am Ende dieselbe Länge wie der zu Beginn eingegebene Plaintext besitzen.
    </system:String>
    <system:String x:Key="Step17">Erweiterung/Zu beachten:
        Der Initialisierungsvektor muss unique sein, ansonsten besteht die Möglichkeit Rückschlüsse auf den Plaintext zu machen. 
        Dies deshalb, weil zwei gleiche Counter-Blöcke auch genau gleich verschlüsselt werden. Unterschiede im Ciphertext stammen allein daher,
        dass Unterschiede im Plaintext vorhanden sind.

        Die Grösse des zu verschlüsselnden Plaintextes pro IV ist genau aus diesem Grund beschränkt. Werden nämlich zu viele Counter-Blöcke gebildet
        steigt die Wahrscheinlichkeit einer Wiederholung der Bit-Sequenzen immer mehr an. Der Plaintext darf deshalb eine Grösse von 64GB nicht übersteigen.
    </system:String>
    <system:String x:Key="Step18">Rückblick:
        Der AES-GCM Algorithmus bietet eine Möglichkeit für die gleichzeitige Verschlüsselung und Authentifizierung von Plaintext.
        Ein grosser Vorteil dabei ist die Geschwindigkeit. Einerseits können alle Counter-Blöcke vorberechnet werden, sobald der IV und die
        Plaintext-Länge bekannt sind. Andererseits kann die Authentifizierung von Ciphertext-Blöcken (grün markiert, mit Input Plaintext X) und die
        Verschlüsselung von weiteren Plaintext-Blöcken (orange markiert, mit Input Plaintext X + 1) unabhängig voneinander, und somit parallel, ablaufen.
    </system:String>
    <system:String x:Key="Step19">Weiter bietet die Verwendung des Counter-Block Mode (CTR) folgenden Vorteil gegenüber dem Electronic Codebook Mode (ECB-Mode): 
        Wird beispielsweise ein Bild, mit vielen gleichen Farbpunkten, verschlüsselt, so sehen die Plaintext-Blöcke mit gleichen Farbpunkten nach
        der Verschlüsselung beim ECB-Mode alle gleich aus. Beim Counter-Block Mode wird dies mittels jeweils unterschiedlichen Counter-Blöcken
        verhindert und es können beispielsweise bei Bildern keine Muster mehr erkannt werden.
    </system:String>
    
    <system:String x:Key="VorbereitungText">
        Erklärung zu Vorbereitung
    </system:String>

    <system:String x:Key="VerschlüsselungText">
        Erklärung zu Verschlüsselung
    </system:String>

    <system:String x:Key="AdditionalAuthenticatedDataText">
        Erklärung zu Additional Authenticated Data
    </system:String>

    <system:String x:Key="CiphertextAuthentifizierungText">
        Erklärung zu Ciphertext Authentifizierung
    </system:String>

    <system:String x:Key="WiederholungText">
        Erklärung zu Wiederholung
    </system:String>

    <system:String x:Key="AbschlussUndRückgabeText">
        Erklärung zu Abschluss und Rückgabe
    </system:String>

    







</ResourceDictionary>